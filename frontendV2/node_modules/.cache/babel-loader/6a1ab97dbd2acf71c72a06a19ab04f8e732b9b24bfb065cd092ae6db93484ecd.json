{"ast":null,"code":"import axios from \"axios\";\n\n// initializing axios\nconst api = axios.create({\n  baseURL: \"/\"\n});\n\n// original source: https://github.com/pilovm/multithreaded-uploader/blob/master/frontend/uploader.js\nexport class Uploader {\n  constructor(options) {\n    this.useTransferAcceleration = options.useTransferAcceleration;\n    // this must be bigger than or equal to 5MB,\n    // otherwise AWS will respond with:\n    // \"Your proposed upload is smaller than the minimum allowed size\"\n    options.chunkSize = options.chunkSize || 0;\n    this.chunkSize = Math.max(1024 * 1024 * options.chunkSize, 1024 * 1024 * 5);\n    // number of parallel uploads\n    options.threadsQuantity = options.threadsQuantity || 0;\n    this.threadsQuantity = Math.min(options.threadsQuantity || 5, 15);\n    // adjust the timeout value to activate exponential backoff retry strategy \n    this.timeout = 0;\n    this.file = options.file;\n    this.fileName = options.fileName;\n    this.aborted = false;\n    this.uploadedSize = 0;\n    this.progressCache = {};\n    this.activeConnections = {};\n    this.parts = [];\n    this.uploadedParts = [];\n    this.fileId = null;\n    this.fileKey = null;\n    this.onProgressFn = () => {};\n    this.onErrorFn = () => {};\n    this.baseURL = options.baseURL;\n  }\n  start() {\n    this.initialize();\n  }\n  async initialize() {\n    try {\n      // adding the the file extension (if present) to fileName\n      let fileName = this.file.name;\n\n      // initializing the multipart request\n      const videoInitializationUploadInput = {\n        name: fileName\n      };\n      const initializeReponse = await api.request({\n        url: \"/initialize\",\n        method: \"POST\",\n        data: videoInitializationUploadInput,\n        baseURL: this.baseURL\n      });\n      const AWSFileDataOutput = initializeReponse.data;\n      this.fileId = AWSFileDataOutput.fileId;\n      this.fileKey = AWSFileDataOutput.fileKey;\n\n      // retrieving the pre-signed URLs\n      const numberOfparts = Math.ceil(this.file.size / this.chunkSize);\n      const AWSMultipartFileDataInput = {\n        fileId: this.fileId,\n        fileKey: this.fileKey,\n        parts: numberOfparts\n      };\n      const urlsResponse = await api.request({\n        url: this.useTransferAcceleration ? \"/getPreSignedTAUrls\" : \"/getPreSignedUrls\",\n        method: \"POST\",\n        data: AWSMultipartFileDataInput,\n        baseURL: this.baseURL\n      });\n      const newParts = urlsResponse.data.parts;\n      this.parts.push(...newParts);\n      this.sendNext();\n    } catch (error) {\n      await this.complete(error);\n    }\n  }\n  sendNext() {\n    let retry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    const activeConnections = Object.keys(this.activeConnections).length;\n    if (activeConnections >= this.threadsQuantity) {\n      return;\n    }\n    if (!this.parts.length) {\n      if (!activeConnections) {\n        this.complete();\n      }\n      return;\n    }\n    const part = this.parts.pop();\n    if (this.file && part) {\n      const sentSize = (part.PartNumber - 1) * this.chunkSize;\n      const chunk = this.file.slice(sentSize, sentSize + this.chunkSize);\n      const sendChunkStarted = () => {\n        this.sendNext();\n      };\n      this.sendChunk(chunk, part, sendChunkStarted).then(() => {\n        this.sendNext();\n      }).catch(error => {\n        if (retry <= 6) {\n          retry++;\n          const wait = ms => new Promise(res => setTimeout(res, ms));\n          //exponential backoff retry before giving up\n          console.log(`Part#${part.PartNumber} failed to upload, backing off ${2 ** retry * 100} before retrying...`);\n          wait(2 ** retry * 100).then(() => {\n            this.parts.push(part);\n            this.sendNext(retry);\n          });\n        } else {\n          console.log(`Part#${part.PartNumber} failed to upload, giving up`);\n          this.complete(error);\n        }\n      });\n    }\n  }\n  async complete(error) {\n    if (error && !this.aborted) {\n      this.onErrorFn(error);\n      return;\n    }\n    if (error) {\n      this.onErrorFn(error);\n      return;\n    }\n    try {\n      await this.sendCompleteRequest();\n    } catch (error) {\n      this.onErrorFn(error);\n    }\n  }\n  async sendCompleteRequest() {\n    if (this.fileId && this.fileKey) {\n      const videoFinalizationMultiPartInput = {\n        fileId: this.fileId,\n        fileKey: this.fileKey,\n        parts: this.uploadedParts\n      };\n      await api.request({\n        url: \"/finalize\",\n        method: \"POST\",\n        data: videoFinalizationMultiPartInput,\n        baseURL: this.baseURL\n      });\n    }\n  }\n  sendChunk(chunk, part, sendChunkStarted) {\n    return new Promise((resolve, reject) => {\n      this.upload(chunk, part, sendChunkStarted).then(status => {\n        if (status !== 200) {\n          reject(new Error(\"Failed chunk upload\"));\n          return;\n        }\n        resolve();\n      }).catch(error => {\n        reject(error);\n      });\n    });\n  }\n  handleProgress(part, event) {\n    if (this.file) {\n      if (event.type === \"progress\" || event.type === \"error\" || event.type === \"abort\") {\n        this.progressCache[part] = event.loaded;\n      }\n      if (event.type === \"uploaded\") {\n        this.uploadedSize += this.progressCache[part] || 0;\n        delete this.progressCache[part];\n      }\n      const inProgress = Object.keys(this.progressCache).map(Number).reduce((memo, id) => memo += this.progressCache[id], 0);\n      const sent = Math.min(this.uploadedSize + inProgress, this.file.size);\n      const total = this.file.size;\n      const percentage = Math.round(sent / total * 100);\n      this.onProgressFn({\n        sent: sent,\n        total: total,\n        percentage: percentage\n      });\n    }\n  }\n  upload(file, part, sendChunkStarted) {\n    // uploading each part with its pre-signed URL\n    return new Promise((resolve, reject) => {\n      const throwXHRError = (error, part, abortFx) => {\n        delete this.activeConnections[part.PartNumber - 1];\n        reject(error);\n        window.removeEventListener('offline', abortFx);\n      };\n      if (this.fileId && this.fileKey) {\n        if (!window.navigator.onLine) reject(new Error(\"System is offline\"));\n        const xhr = this.activeConnections[part.PartNumber - 1] = new XMLHttpRequest();\n        xhr.timeout = this.timeout;\n        sendChunkStarted();\n        const progressListener = this.handleProgress.bind(this, part.PartNumber - 1);\n        xhr.upload.addEventListener(\"progress\", progressListener);\n        xhr.addEventListener(\"error\", progressListener);\n        xhr.addEventListener(\"abort\", progressListener);\n        xhr.addEventListener(\"loadend\", progressListener);\n        xhr.open(\"PUT\", part.signedUrl);\n        const abortXHR = () => xhr.abort();\n        xhr.onreadystatechange = () => {\n          if (xhr.readyState === 4 && xhr.status === 200) {\n            const ETag = xhr.getResponseHeader(\"ETag\");\n            if (ETag) {\n              const uploadedPart = {\n                PartNumber: part.PartNumber,\n                ETag: ETag.replaceAll('\"', \"\")\n              };\n              this.uploadedParts.push(uploadedPart);\n              resolve(xhr.status);\n              delete this.activeConnections[part.PartNumber - 1];\n              window.removeEventListener('offline', abortXHR);\n            }\n          }\n        };\n        xhr.onerror = error => {\n          throwXHRError(error, part, abortXHR);\n        };\n        xhr.ontimeout = error => {\n          throwXHRError(error, part, abortXHR);\n        };\n        xhr.onabort = () => {\n          throwXHRError(new Error(\"Upload canceled by user or system\"), part);\n        };\n        window.addEventListener('offline', abortXHR);\n        xhr.send(file);\n      }\n    });\n  }\n  onProgress(onProgress) {\n    this.onProgressFn = onProgress;\n    return this;\n  }\n  onError(onError) {\n    this.onErrorFn = onError;\n    return this;\n  }\n  abort() {\n    Object.keys(this.activeConnections).map(Number).forEach(id => {\n      this.activeConnections[id].abort();\n    });\n    this.aborted = true;\n  }\n}","map":{"version":3,"names":["axios","api","create","baseURL","Uploader","constructor","options","useTransferAcceleration","chunkSize","Math","max","threadsQuantity","min","timeout","file","fileName","aborted","uploadedSize","progressCache","activeConnections","parts","uploadedParts","fileId","fileKey","onProgressFn","onErrorFn","start","initialize","name","videoInitializationUploadInput","initializeReponse","request","url","method","data","AWSFileDataOutput","numberOfparts","ceil","size","AWSMultipartFileDataInput","urlsResponse","newParts","push","sendNext","error","complete","retry","arguments","length","undefined","Object","keys","part","pop","sentSize","PartNumber","chunk","slice","sendChunkStarted","sendChunk","then","catch","wait","ms","Promise","res","setTimeout","console","log","sendCompleteRequest","videoFinalizationMultiPartInput","resolve","reject","upload","status","Error","handleProgress","event","type","loaded","inProgress","map","Number","reduce","memo","id","sent","total","percentage","round","throwXHRError","abortFx","window","removeEventListener","navigator","onLine","xhr","XMLHttpRequest","progressListener","bind","addEventListener","open","signedUrl","abortXHR","abort","onreadystatechange","readyState","ETag","getResponseHeader","uploadedPart","replaceAll","onerror","ontimeout","onabort","send","onProgress","onError","forEach"],"sources":["C:/Users/a.tiwari/git/amazon-s3-multipart-upload-transfer-acceleration/src/utils/upload.js"],"sourcesContent":["import axios from \"axios\"\r\n\r\n// initializing axios\r\nconst api = axios.create({\r\n  baseURL: \"/\",\r\n})\r\n\r\n// original source: https://github.com/pilovm/multithreaded-uploader/blob/master/frontend/uploader.js\r\nexport class Uploader {\r\n  constructor(options) {\r\n    this.useTransferAcceleration = options.useTransferAcceleration\r\n    // this must be bigger than or equal to 5MB,\r\n    // otherwise AWS will respond with:\r\n    // \"Your proposed upload is smaller than the minimum allowed size\"\r\n    options.chunkSize = options.chunkSize || 0\r\n    this.chunkSize = Math.max((1024 * 1024 * options.chunkSize), (1024 * 1024 * 5))\r\n    // number of parallel uploads\r\n    options.threadsQuantity = options.threadsQuantity || 0\r\n    this.threadsQuantity = Math.min(options.threadsQuantity || 5, 15)\r\n    // adjust the timeout value to activate exponential backoff retry strategy \r\n    this.timeout = 0\r\n    this.file = options.file\r\n    this.fileName = options.fileName\r\n    this.aborted = false\r\n    this.uploadedSize = 0\r\n    this.progressCache = {}\r\n    this.activeConnections = {}\r\n    this.parts = []\r\n    this.uploadedParts = []\r\n    this.fileId = null\r\n    this.fileKey = null\r\n    this.onProgressFn = () => {}\r\n    this.onErrorFn = () => {}\r\n    this.baseURL = options.baseURL\r\n  }\r\n\r\n  start() {\r\n    this.initialize()\r\n  }\r\n\r\n  async initialize() {\r\n    try {\r\n      // adding the the file extension (if present) to fileName\r\n      let fileName = this.file.name\r\n\r\n      // initializing the multipart request\r\n      const videoInitializationUploadInput = {\r\n        name: fileName,\r\n      }\r\n      const initializeReponse = await api.request({\r\n        url: \"/initialize\",\r\n        method: \"POST\",\r\n        data: videoInitializationUploadInput,\r\n        baseURL:this.baseURL\r\n      })\r\n\r\n      const AWSFileDataOutput = initializeReponse.data\r\n\r\n      this.fileId = AWSFileDataOutput.fileId\r\n      this.fileKey = AWSFileDataOutput.fileKey\r\n\r\n      // retrieving the pre-signed URLs\r\n      const numberOfparts = Math.ceil(this.file.size / this.chunkSize)\r\n\r\n      const AWSMultipartFileDataInput = {\r\n        fileId: this.fileId,\r\n        fileKey: this.fileKey,\r\n        parts: numberOfparts,\r\n      }\r\n\r\n      const urlsResponse = await api.request({\r\n        url: this.useTransferAcceleration?\"/getPreSignedTAUrls\":\"/getPreSignedUrls\",\r\n        method: \"POST\",\r\n        data: AWSMultipartFileDataInput,\r\n        baseURL:this.baseURL\r\n      })\r\n\r\n      const newParts = urlsResponse.data.parts\r\n      this.parts.push(...newParts)\r\n\r\n      this.sendNext()\r\n    } catch (error) {\r\n      await this.complete(error)\r\n    }\r\n  }\r\n\r\n  sendNext(retry=0) {\r\n    const activeConnections = Object.keys(this.activeConnections).length\r\n\r\n    if (activeConnections >= this.threadsQuantity) {\r\n      return\r\n    }\r\n\r\n    if (!this.parts.length) {\r\n      if (!activeConnections) {\r\n        this.complete()\r\n      }\r\n\r\n      return\r\n    }\r\n\r\n    const part = this.parts.pop()    \r\n    if (this.file && part) {\r\n      const sentSize = (part.PartNumber - 1) * this.chunkSize\r\n      const chunk = this.file.slice(sentSize, sentSize + this.chunkSize)\r\n\r\n      const sendChunkStarted = () => {\r\n        this.sendNext()\r\n      }\r\n\r\n      this.sendChunk(chunk, part, sendChunkStarted)\r\n        .then(() => {\r\n          this.sendNext()\r\n        })\r\n        .catch((error) => {          \r\n          if (retry <= 6){\r\n            retry++\r\n            const wait = (ms) => new Promise((res) => setTimeout(res, ms));\r\n            //exponential backoff retry before giving up\r\n            console.log(`Part#${part.PartNumber} failed to upload, backing off ${2 ** retry * 100} before retrying...`)\r\n            wait(2 ** retry * 100).then(() => {              \r\n              this.parts.push(part)\r\n              this.sendNext(retry)\r\n            })\r\n          }else{\r\n            console.log(`Part#${part.PartNumber} failed to upload, giving up`)\r\n            this.complete(error)\r\n          }\r\n        })\r\n    }\r\n  }\r\n\r\n  async complete(error) {\r\n    if (error && !this.aborted) {\r\n      this.onErrorFn(error)\r\n      return\r\n    }\r\n\r\n    if (error) {\r\n      this.onErrorFn(error)\r\n      return\r\n    }\r\n\r\n    try {\r\n      await this.sendCompleteRequest()\r\n    } catch (error) {\r\n      this.onErrorFn(error)\r\n    }\r\n  }\r\n\r\n  async sendCompleteRequest() {\r\n    if (this.fileId && this.fileKey) {\r\n      const videoFinalizationMultiPartInput = {\r\n        fileId: this.fileId,\r\n        fileKey: this.fileKey,\r\n        parts: this.uploadedParts,\r\n      }\r\n\r\n      await api.request({\r\n        url: \"/finalize\",\r\n        method: \"POST\",\r\n        data: videoFinalizationMultiPartInput,\r\n        baseURL:this.baseURL\r\n      })\r\n    }\r\n  }\r\n\r\n  sendChunk(chunk, part, sendChunkStarted) {\r\n    return new Promise((resolve, reject) => {\r\n      this.upload(chunk, part, sendChunkStarted)\r\n        .then((status) => {\r\n          if (status !== 200) {\r\n            reject(new Error(\"Failed chunk upload\"))\r\n            return\r\n          }\r\n\r\n          resolve()\r\n        })\r\n        .catch((error) => {\r\n          reject(error)\r\n        })\r\n    })\r\n  }\r\n\r\n  handleProgress(part, event) {\r\n    if (this.file) {\r\n      if (event.type === \"progress\" || event.type === \"error\" || event.type === \"abort\") {\r\n        this.progressCache[part] = event.loaded\r\n      }\r\n\r\n      if (event.type === \"uploaded\") {\r\n        this.uploadedSize += this.progressCache[part] || 0\r\n        delete this.progressCache[part]\r\n      }\r\n\r\n      const inProgress = Object.keys(this.progressCache)\r\n        .map(Number)\r\n        .reduce((memo, id) => (memo += this.progressCache[id]), 0)\r\n\r\n      const sent = Math.min(this.uploadedSize + inProgress, this.file.size)\r\n\r\n      const total = this.file.size\r\n\r\n      const percentage = Math.round((sent / total) * 100)\r\n\r\n      this.onProgressFn({\r\n        sent: sent,\r\n        total: total,\r\n        percentage: percentage,\r\n      })\r\n    }\r\n  }\r\n\r\n  upload(file, part, sendChunkStarted) {\r\n    // uploading each part with its pre-signed URL\r\n    return new Promise((resolve, reject) => {\r\n      const throwXHRError = (error, part, abortFx) => {    \r\n        delete this.activeConnections[part.PartNumber - 1]\r\n        reject(error)\r\n        window.removeEventListener('offline', abortFx)    \r\n      }      \r\n      if (this.fileId && this.fileKey) {\r\n        if(!window.navigator.onLine)\r\n          reject(new Error(\"System is offline\"))\r\n\r\n        const xhr = (this.activeConnections[part.PartNumber - 1] = new XMLHttpRequest())\r\n        xhr.timeout = this.timeout\r\n        sendChunkStarted()\r\n\r\n        const progressListener = this.handleProgress.bind(this, part.PartNumber - 1)\r\n\r\n        xhr.upload.addEventListener(\"progress\", progressListener)\r\n\r\n        xhr.addEventListener(\"error\", progressListener)\r\n        xhr.addEventListener(\"abort\", progressListener)\r\n        xhr.addEventListener(\"loadend\", progressListener)\r\n\r\n        xhr.open(\"PUT\", part.signedUrl)\r\n        const abortXHR = () => xhr.abort()\r\n        xhr.onreadystatechange = () => {\r\n          if (xhr.readyState === 4 && xhr.status === 200) {\r\n            const ETag = xhr.getResponseHeader(\"ETag\")\r\n\r\n            if (ETag) {\r\n              const uploadedPart = {\r\n                PartNumber: part.PartNumber,\r\n                ETag: ETag.replaceAll('\"', \"\"),\r\n              }\r\n\r\n              this.uploadedParts.push(uploadedPart)\r\n\r\n              resolve(xhr.status)\r\n              delete this.activeConnections[part.PartNumber - 1]\r\n              window.removeEventListener('offline', abortXHR)\r\n            }\r\n          }\r\n        }\r\n\r\n        xhr.onerror = (error) => {\r\n          throwXHRError(error, part, abortXHR)\r\n        }\r\n        xhr.ontimeout = (error) => {\r\n          throwXHRError(error, part, abortXHR)\r\n        }\r\n        xhr.onabort = () => {\r\n          throwXHRError(new Error(\"Upload canceled by user or system\"), part)\r\n        }\r\n        window.addEventListener('offline', abortXHR);\r\n        xhr.send(file)\r\n      }\r\n    })\r\n  }\r\n\r\n\r\n\r\n  onProgress(onProgress) {\r\n    this.onProgressFn = onProgress\r\n    return this\r\n  }\r\n\r\n  onError(onError) {\r\n    this.onErrorFn = onError\r\n    return this\r\n  }\r\n\r\n  abort() {\r\n    Object.keys(this.activeConnections)\r\n      .map(Number)\r\n      .forEach((id) => {\r\n        this.activeConnections[id].abort()\r\n      })\r\n\r\n    this.aborted = true\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}